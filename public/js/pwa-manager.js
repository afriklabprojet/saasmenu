class PWAManager { constructor() { this.deferredPrompt=null; this.isInstalled=false; this.serviceWorker=null; this.pushManager=null; this.init(); } async init() { console.log('üöÄ Initialisation du gestionnaire PWA E-menu'); if (!this.isPWASupported()) { console.warn('PWA non support√© sur ce navigateur'); return; } await this.registerServiceWorker(); this.setupInstallPrompt(); this.setupNotifications(); this.setupEventListeners(); this.checkInstallStatus(); console.log('‚úÖ Gestionnaire PWA initialis√©'); } isPWASupported() { return 'serviceWorker' in navigator&&'PushManager' in window; } async registerServiceWorker() { try { const registration=await navigator.serviceWorker.register('/sw.js', { scope: '/' }); this.serviceWorker=registration; console.log('‚úÖ Service Worker enregistr√©:', registration.scope); registration.addEventListener('updatefound', () => { console.log('üîÑ Mise √† jour du Service Worker d√©tect√©e'); this.handleServiceWorkerUpdate(registration); }); } catch (error) { console.error('‚ùå Erreur enregistrement Service Worker:', error); } } setupInstallPrompt() { window.addEventListener('beforeinstallprompt', (event) => { console.log('üì± PWA installable d√©tect√©e'); event.preventDefault(); this.deferredPrompt=event; this.showInstallButton(); }); window.addEventListener('appinstalled', (event) => { console.log('‚úÖ PWA install√©e'); this.isInstalled=true; this.hideInstallButton(); this.trackInstall(); }); } async setupNotifications() { if (!('Notification' in window)||!('PushManager' in window)) { console.warn('Notifications non support√©es'); return; } try { const registration=await navigator.serviceWorker.ready; this.pushManager=registration.pushManager; const permission=await Notification.requestPermission(); console.log('üîî Permission notifications:', permission); } catch (error) { console.error('‚ùå Erreur configuration notifications:', error); } } setupEventListeners() { const installBtn=document.getElementById('pwa-install-btn'); if (installBtn) { installBtn.addEventListener('click', () => this.promptInstall()); } const notifyBtn=document.getElementById('pwa-notify-btn'); if (notifyBtn) { notifyBtn.addEventListener('click', () => this.enableNotifications()); } window.addEventListener('online', () => this.handleOnline()); window.addEventListener('offline', () => this.handleOffline()); document.addEventListener('visibilitychange', () => { if (!document.hidden&&this.serviceWorker) { this.checkForUpdates(); } }); } checkInstallStatus() { if (window.matchMedia&&window.matchMedia('(display-mode: standalone)').matches) { this.isInstalled=true; console.log('‚úÖ Application en mode standalone'); } if (window.navigator.standalone === true) { this.isInstalled=true; console.log('‚úÖ Application install√©e sur iOS'); } if (this.isInstalled) { this.hideInstallButton(); } } async promptInstall() { if (!this.deferredPrompt) { console.warn('Installation PWA non disponible'); return false; } try { this.deferredPrompt.prompt(); const result=await this.deferredPrompt.userChoice; console.log('üéØ R√©ponse installation:', result.outcome); if (result.outcome === 'accepted') { console.log('‚úÖ Installation accept√©e'); this.trackInstallAttempt(true); } else { console.log('‚ùå Installation refus√©e'); this.trackInstallAttempt(false); } this.deferredPrompt=null; return result.outcome === 'accepted'; } catch (error) { console.error('‚ùå Erreur installation:', error); return false; } } async enableNotifications() { try { const permission=await Notification.requestPermission(); if (permission !== 'granted') { console.warn('Permission notifications refus√©e'); this.showNotificationError('Permission refus√©e'); return false; } const subscription=await this.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: this.urlBase64ToUint8Array(this.getVapidPublicKey()) }); const response=await fetch('/pwa/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') }, body: JSON.stringify(subscription.toJSON()) }); if (response.ok) { console.log('‚úÖ Notifications activ√©es'); this.showNotificationSuccess('Notifications activ√©es avec succ√®s'); this.updateNotificationButton(true); return true; } else { throw new Error('Erreur serveur lors de l\'abonnement'); } } catch (error) { console.error('‚ùå Erreur activation notifications:', error); this.showNotificationError('Erreur lors de l\'activation'); return false; } } async disableNotifications() { try { const subscription=await this.pushManager.getSubscription(); if (subscription) { await subscription.unsubscribe(); await fetch('/pwa/unsubscribe', { method: 'POST', headers: { 'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') } }); } console.log('‚úÖ Notifications d√©sactiv√©es'); this.showNotificationSuccess('Notifications d√©sactiv√©es'); this.updateNotificationButton(false); } catch (error) { console.error('‚ùå Erreur d√©sactivation notifications:', error); } } handleServiceWorkerUpdate(registration) { const newWorker=registration.installing; if (newWorker) { newWorker.addEventListener('statechange', () => { if (newWorker.state === 'installed'&&navigator.serviceWorker.controller) { this.showUpdatePrompt(); } }); } } handleOnline() { console.log('üåê Connexion r√©tablie'); this.hideOfflineIndicator(); if (this.serviceWorker&&this.serviceWorker.sync) { this.serviceWorker.sync.register('background-sync'); } } handleOffline() { console.log('üìµ Mode hors ligne activ√©'); this.showOfflineIndicator(); } async checkForUpdates() { try { const registration=await navigator.serviceWorker.getRegistration(); if (registration) { await registration.update(); } } catch (error) { console.error('‚ùå Erreur v√©rification mises √† jour:', error); } } showInstallButton() { const btn=document.getElementById('pwa-install-btn'); if (btn) { btn.style.display='block'; btn.classList.add('animate__fadeIn'); } } hideInstallButton() { const btn=document.getElementById('pwa-install-btn'); if (btn) { btn.style.display='none'; } } showOfflineIndicator() { let indicator=document.getElementById('offline-indicator'); if (!indicator) { indicator=document.createElement('div'); indicator.id='offline-indicator'; indicator.className='alert alert-warning fixed-top text-center'; indicator.innerHTML='üìµ Mode hors ligne-Certaines fonctionnalit√©s peuvent √™tre limit√©es'; document.body.appendChild(indicator); } indicator.style.display='block'; } hideOfflineIndicator() { const indicator=document.getElementById('offline-indicator'); if (indicator) { indicator.style.display='none'; } } showNotificationSuccess(message) { this.showToast(message, 'success'); } showNotificationError(message) { this.showToast(message, 'error'); } showToast(message, type='info') { const toast=document.createElement('div'); toast.className=`alert alert-${type === 'success' ? 'success' : 'danger'} toast-notification`; toast.style.cssText='position: fixed; top: 20px; right: 20px; z-index: 9999; min-width: 300px;'; toast.innerHTML=` <strong>${type === 'success' ? '‚úÖ' : '‚ùå'}</strong> ${message} <button type="button" class="btn-close float-end" onclick="this.parentElement.remove()"></button> `; document.body.appendChild(toast); setTimeout(() => { if (toast.parentElement) { toast.remove(); } }, 5000); } updateNotificationButton(enabled) { const btn=document.getElementById('pwa-notify-btn'); if (btn) { btn.textContent=enabled ? 'üîî Notifications activ√©es' : 'üîï Activer les notifications'; btn.onclick=enabled ? () => this.disableNotifications() : () => this.enableNotifications(); } } showUpdatePrompt() { const updatePrompt=document.createElement('div'); updatePrompt.className='alert alert-info fixed-top text-center'; updatePrompt.innerHTML=` <strong>üîÑ Mise √† jour disponible</strong> <button class="btn btn-primary btn-sm ms-2" onclick="window.pwaManager.applyUpdate()"> Mettre √† jour </button> <button class="btn btn-secondary btn-sm ms-1" onclick="this.parentElement.remove()"> Plus tard </button> `; document.body.appendChild(updatePrompt); } async applyUpdate() { if (this.serviceWorker&&this.serviceWorker.waiting) { this.serviceWorker.waiting.postMessage({ type: 'SKIP_WAITING' }); window.location.reload(); } } urlBase64ToUint8Array(base64String) { const padding='='.repeat((4-base64String.length % 4) % 4); const base64=(base64String+padding) .replace(/-/g, '+') .replace(/_/g, '/'); const rawData=window.atob(base64); const outputArray=new Uint8Array(rawData.length); for (let i=0; i < rawData.length; ++i) { outputArray[i]=rawData.charCodeAt(i); } return outputArray; } getVapidPublicKey() { return 'YOUR_VAPID_PUBLIC_KEY_HERE'; } trackInstall() { console.log('üìä PWA install√©e-√©v√©nement suivi'); } trackInstallAttempt(accepted) { console.log('üìä Tentative installation:', accepted ? 'accept√©e' : 'refus√©e'); } } document.addEventListener('DOMContentLoaded', () => { window.pwaManager=new PWAManager(); }); if (typeof module !== 'undefined'&&module.exports) { module.exports=PWAManager; }